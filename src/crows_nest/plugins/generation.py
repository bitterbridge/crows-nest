"""Plugin generation operation.

Generates plugin code from natural language specifications using an LLM.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any
from uuid import UUID

from pydantic import BaseModel, Field

from crows_nest.agents.llm import (
    ChatMessage,
    LLMProvider,
    create_provider,
)
from crows_nest.core.registry import thunk_operation
from crows_nest.plugins.artifacts import (
    OperationSpec,
    ParameterSpec,
    PluginArtifact,
)

if TYPE_CHECKING:
    from crows_nest.llm.providers import ProviderConfig

# Pydantic models for structured LLM output


class GeneratedParameter(BaseModel):
    """A parameter generated by the LLM."""

    name: str = Field(description="Parameter name (valid Python identifier)")
    type_annotation: str = Field(
        description="Python type annotation (e.g., 'str', 'dict[str, Any]')"
    )
    description: str = Field(description="Description of what this parameter does")
    required: bool = Field(default=True, description="Whether this parameter is required")
    default_value: Any = Field(default=None, description="Default value if not required")


class GeneratedOperation(BaseModel):
    """An operation generated by the LLM."""

    name: str = Field(description="Operation name (e.g., 'json.parse')")
    description: str = Field(description="Description of what this operation does")
    parameters: list[GeneratedParameter] = Field(
        default_factory=list, description="Operation parameters"
    )
    return_type: str = Field(default="dict[str, Any]", description="Return type annotation")
    required_capabilities: list[str] = Field(
        default_factory=list,
        description="Capabilities needed (e.g., 'file.read', 'network')",
    )


class GeneratedPlugin(BaseModel):
    """Plugin code generated by the LLM."""

    name: str = Field(description="Plugin name (valid Python module name)")
    description: str = Field(description="What this plugin does")
    source_code: str = Field(description="Complete Python source code for the plugin")
    operations: list[GeneratedOperation] = Field(description="Operations this plugin provides")
    requested_capabilities: list[str] = Field(
        default_factory=list,
        description="All capabilities the plugin needs",
    )


# Global LLM provider (lazily initialized)
_llm_provider: LLMProvider | None = None
_llm_config: ProviderConfig | None = None


def get_llm_provider() -> LLMProvider:
    """Get the global LLM provider.

    Returns:
        The LLM provider instance.

    Raises:
        RuntimeError: If no provider has been configured.
    """
    if _llm_provider is None:
        msg = "LLM provider not configured. Call configure_llm_provider first."
        raise RuntimeError(msg)
    return _llm_provider


def configure_llm_provider(config: ProviderConfig) -> None:
    """Configure the global LLM provider.

    Args:
        config: LLM configuration.
    """
    global _llm_provider, _llm_config  # noqa: PLW0603
    _llm_config = config
    _llm_provider = create_provider(config)


def reset_llm_provider() -> None:
    """Reset the global LLM provider (for testing)."""
    global _llm_provider, _llm_config  # noqa: PLW0603
    _llm_provider = None
    _llm_config = None


PLUGIN_GENERATION_PROMPT = """\
You are a plugin code generator for the Crow's Nest agent framework.

Generate a Python plugin based on the user's specification. The plugin must:

1. Use the @thunk_operation decorator from crows_nest.core.registry
2. Define async functions for each operation
3. Return dict results (JSON-serializable)
4. Only use standard library modules plus these allowed imports:
   - crows_nest.core.registry (for thunk_operation)
   - json, re, datetime, collections, itertools, functools
5. NOT use any I/O unless explicitly requested (no file, network, subprocess)
6. Include proper type hints
7. Be self-contained (no external dependencies beyond allowed imports)

Example plugin structure:
```python
\"\"\"Description of what this plugin does.\"\"\"

from crows_nest.core.registry import thunk_operation

@thunk_operation(
    name="namespace.operation",
    description="What this operation does",
    required_capabilities=frozenset(),  # or frozenset({"file.read"}) if needed
)
async def operation_name(param1: str, param2: int = 10) -> dict:
    \"\"\"Docstring explaining the operation.\"\"\"
    # Implementation
    return {"result": "value"}
```

Generate clean, well-documented code that exactly matches the specification.
"""


@thunk_operation(
    name="plugin.generate",
    description="Generate plugin code from a natural language specification.",
    required_capabilities=frozenset({"plugin.generate"}),
)
async def plugin_generate(
    spec: str,
    target_operations: list[str],
    example_inputs: list[dict[str, Any]] | None = None,
    example_outputs: list[Any] | None = None,
    agent_id: str | None = None,
    context: dict[str, Any] | None = None,
) -> dict[str, Any]:
    """Generate plugin code from a specification.

    Uses an LLM to generate Python code that registers operations
    matching the specification. The generated code is NOT executed -
    it must go through verification and approval first.

    Args:
        spec: Natural language description of what the plugin should do.
        target_operations: List of operation names to create (e.g., ["json.parse"]).
        example_inputs: Example inputs for testing (optional).
        example_outputs: Expected outputs for examples (optional).
        agent_id: ID of the agent requesting generation.
        context: Additional context about why this plugin is needed.

    Returns:
        Dict containing the generated PluginArtifact as a dict, or error info.
    """
    try:
        provider = get_llm_provider()
    except RuntimeError as e:
        return {
            "success": False,
            "error": str(e),
            "error_type": "configuration_error",
        }

    # Build the user message with the spec
    user_content = f"""Generate a plugin with the following specification:

**Description**: {spec}

**Operations to create**: {", ".join(target_operations)}
"""

    if example_inputs and example_outputs:
        user_content += "\n**Examples**:\n"
        for i, (inp, out) in enumerate(zip(example_inputs, example_outputs, strict=False)):
            user_content += f"  Input {i + 1}: {inp}\n"
            user_content += f"  Expected Output {i + 1}: {out}\n"

    if context:
        user_content += f"\n**Context**: {context}\n"

    messages = [ChatMessage(role="user", content=user_content)]

    try:
        result = await provider.complete_async(
            messages=messages,
            output_schema=GeneratedPlugin,
            system_prompt=PLUGIN_GENERATION_PROMPT,
        )

        generated: GeneratedPlugin = result.content

        # Convert to PluginArtifact
        operations = tuple(
            OperationSpec(
                name=op.name,
                description=op.description,
                parameters=tuple(
                    ParameterSpec(
                        name=p.name,
                        type_annotation=p.type_annotation,
                        description=p.description,
                        required=p.required,
                        default=p.default_value,
                    )
                    for p in op.parameters
                ),
                required_capabilities=frozenset(op.required_capabilities),
                return_type=op.return_type,
            )
            for op in generated.operations
        )

        artifact = PluginArtifact.create(
            name=generated.name,
            description=generated.description,
            source_code=generated.source_code,
            operations=list(operations),
            requested_capabilities=set(generated.requested_capabilities),
            generated_by=UUID(agent_id) if agent_id else UUID(int=0),
            generation_context={
                "spec": spec,
                "target_operations": target_operations,
                "example_inputs": example_inputs,
                "example_outputs": example_outputs,
                **(context or {}),
            },
        )

        return {
            "success": True,
            "artifact": artifact.to_dict(),
            "artifact_id": str(artifact.id),
            "content_hash": artifact.content_hash(),
        }

    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "error_type": type(e).__name__,
        }
